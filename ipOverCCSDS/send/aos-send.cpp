#include <sys/socket.h>
#include <sys/select.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <strings.h>
#include <iostream>
#include <memory>
#include <cerrno>
#include <cstdio>
#include <cstdlib>
#include <thread>
#include <unistd.h>
#include <chrono>
#include <iomanip>
#include <fstream>
constexpr int MAXLINE=600000;
constexpr int port1=3021;
using namespace std;
//空闲包 用于维持链路同步
unsigned char idle[]={0x49,0x96,0x02,0xD2,0x00,0x00,0x04,0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,
0x1A,0xCF,0xFC,0x1D,0xaa,0xaa,0xaa,0xaa,0x81,0x96,0x22,0xf0,0x61,0x57,0xb8,0x9f, 
0xbe,0xaf,0xb6,0x47,0xce,0xed,0x8c,0xa9,0xf6,0xd1,0x92,0xbf,0x3f,0x0a,0xf3,0xc1,
0x22,0x3e,0x67,0x40,0x1b,0x54,0x3a,0xb7,0x2b,0x9e,0xb0,0x4b,0xd3,0xb6,0xf3,0x8d,
0xf1,0xe5,0xc4,0x27,0x36,0x1f,0x84,0x51,0x32,0xcf,0xef,0xd4,0xd6,0xbe,0x8b,0x49,
0xbb,0x83,0x31,0x7f,0xc9,0x57,0x8a,0x91,0xa8,0xc2,0x9f,0x68,0x58,0x92,0x18,0xe4,
0x1c,0x34,0x77,0xb1,0x93,0xc0,0xf7,0x5d,0x9a,0x60,0x20,0x56,0x52,0x82,0xe9,0x6c,
0x88,0xf9,0x9d,0x00,0x6d,0x50,0xea,0xdc,0xae,0x7a,0xc1,0x2f,0x4e,0xdb,0xce,0x37,
0xc7,0x97,0x10,0x9c,0xd8,0x7e,0x11,0x44,0xcb,0x3f,0xbf,0x53,0x5a,0xfa,0x2d,0x26,
0xee,0x0c,0xc5,0xff,0x25,0x5e,0x2a,0x46,0xa3,0x0a,0x7d,0xa1,0x62,0x48,0x63,0x90,
0x70,0xd1,0xde,0xc6,0x4f,0x03,0xdd,0x76,0x69,0x80,0x81,0x59,0x4a,0x0b,0xa5,0xb2,
0x23,0xe6,0x74,0x01,0xb5,0x43,0xab,0x72,0xb9,0xeb,0x04,0xbd,0x3b,0x6f,0x38,0xdf,
0x1e,0x5c,0x42,0x73,0x61,0xf8,0x45,0x13,0x2c,0xfe,0xfd,0x4d,0x6b,0xe8,0xb4,0x9b,
0xb8,0x33,0x17,0xfc,0x95,0x78,0xa9,0x1a,0x8c,0x29,0xf6,0x85,0x89,0x21,0x8e,0x41,
0xc3,0x47,0x7b,0x19,0x3c,0x0f,0x75,0xd9,0xa6,0x02,0x05,0x65,0x28,0x2e,0x96,0xc8,
0x8f,0x99,0xd0,0x06,0xd5,0x0e,0xad,0xca,0xe7,0xac,0x12,0xf4,0xed,0xbc,0xe3,0x7c,
0x79,0x71,0x09,0xcd,0x87,0xe1,0x14,0x4c,0xb3,0xfb,0xf5,0x35,0xaf,0xa2,0xd2,0x6e,
0xe0,0xcc,0x5f,0xf2,0x55,0xe2,0xa4,0x6a,0x30,0xa7,0xda,0x16,0x24,0x86,0x39,0x07,
0x0d,0x1d,0xec,0x64,0xf0,0x3d,0xd7,0x66,0x98,0x08,0x15,0x94,0xa0,0xba,0x5b,0x22,
0x3e,0x67,0x40,0x1b,0x54,0x3a,0xb7,0x2b,0x9e,0xb0,0x4b,0xd3,0xb6,0xf3,0x8d,0xf1,
0xe5,0xc4,0x27,0x36,0x1f,0x84,0x51,0x32,0xcf,0xef,0xd4,0xd6,0xbe,0x8b,0x49,0xbb,
0x83,0x31,0x7f,0xc9,0x57,0x8a,0x91,0xa8,0xc2,0x9f,0x68,0x58,0x92,0x18,0xe4,0x1c,
0x34,0x77,0xb1,0x93,0xc0,0xf7,0x5d,0x9a,0x60,0x20,0x56,0x52,0x82,0xe9,0x6c,0x88,
0xf9,0x9d,0x00,0x6d,0x50,0xea,0xdc,0xae,0x7a,0xc1,0x2f,0x4e,0xdb,0xce,0x37,0xc7,
0x97,0x10,0x9c,0xd8,0x7e,0x11,0x44,0xcb,0x3f,0xbf,0x53,0x5a,0xfa,0x2d,0x26,0xee,
0x0c,0xc5,0xff,0x25,0x5e,0x2a,0x46,0xa3,0x0a,0x7d,0xa1,0x62,0x48,0x63,0x90,0x70,
0xd1,0xde,0xc6,0x4f,0x03,0xdd,0x76,0x69,0x80,0x81,0x59,0x4a,0x0b,0xa5,0xb2,0x23,
0xe6,0x74,0x01,0xb5,0x43,0xab,0x72,0xb9,0xeb,0x04,0xbd,0x3b,0x6f,0x38,0xdf,0x1e,
0x5c,0x42,0x73,0x61,0xf8,0x45,0x13,0x2c,0xfe,0xfd,0x4d,0x6b,0xe8,0xb4,0x9b,0xb8,
0x33,0x17,0xfc,0x95,0x78,0xa9,0x1a,0x8c,0x29,0xf6,0x85,0x89,0x21,0x8e,0x41,0xc3,
0x47,0x7b,0x19,0x3c,0x0f,0x75,0xd9,0xa6,0x02,0x05,0x65,0x28,0x2e,0x96,0xc8,0x8f,
0x99,0xd0,0x06,0xd5,0x0e,0xad,0xca,0xe7,0xac,0x12,0xf4,0xed,0xbc,0xe3,0x7c,0x79,
0x71,0x09,0xcd,0x87,0xe1,0x14,0x4c,0xb3,0xfb,0xf5,0x35,0xaf,0xa2,0xd2,0x6e,0xe0,
0xcc,0x5f,0xf2,0x55,0xe2,0xa4,0x6a,0x30,0xa7,0xda,0x16,0x24,0x86,0x39,0x07,0x0d,
0x1d,0xec,0x64,0xf0,0x3d,0xd7,0x66,0x98,0x08,0x15,0x94,0xa0,0xba,0x5b,0x22,0x3e,
0x67,0x40,0x1b,0x54,0x3a,0xb7,0x2b,0x9e,0xb0,0x4b,0xd3,0xb6,0xf3,0x8d,0xf1,0xe5,
0xc4,0x27,0x36,0x1f,0x84,0x51,0x32,0xcf,0xef,0xd4,0xd6,0xbe,0x8b,0x49,0xbb,0x83,
0x31,0x7f,0xc9,0x57,0x8a,0x91,0xa8,0xc2,0x9f,0x68,0x58,0x92,0x18,0xe4,0x1c,0x34,
0x77,0xb1,0x93,0xc0,0xf7,0x5d,0x9a,0x60,0x20,0x56,0x52,0x82,0xe9,0x6c,0x88,0xf9,
0x9d,0x00,0x6d,0x50,0xea,0xdc,0xae,0x7a,0xc1,0x2f,0x4e,0xdb,0xce,0x37,0xc7,0x97,
0x10,0x9c,0xd8,0x7e,0x11,0x44,0xcb,0x3f,0xbf,0x53,0x5a,0xfa,0x2d,0x26,0xee,0x0c,
0xc5,0xff,0x25,0x5e,0x2a,0x46,0xa3,0x0a,0x7d,0xa1,0x62,0x48,0x63,0x90,0x70,0xd1,
0xde,0xc6,0x4f,0x03,0xdd,0x76,0x69,0x80,0x81,0x59,0x4a,0x0b,0xa5,0xb2,0x23,0xe6,
0x74,0x01,0xb5,0x43,0xab,0x72,0xb9,0xeb,0x04,0xbd,0x3b,0x6f,0x38,0xdf,0x1e,0x5c,
0x42,0x73,0x61,0xf8,0x45,0x13,0x2c,0xfe,0xfd,0x4d,0x6b,0xe8,0xb4,0x9b,0xb8,0x33,
0x17,0xfc,0x95,0x78,0xa9,0x1a,0x8c,0x29,0xf6,0x85,0x89,0x21,0x8e,0x41,0xc3,0x47,
0x7b,0x19,0x3c,0x0f,0x75,0xd9,0xa6,0x02,0x05,0x65,0x28,0x2e,0x96,0xc8,0x8f,0x99,
0xd0,0x06,0xd5,0x0e,0xad,0xca,0xe7,0xac,0x12,0xf4,0xed,0xbc,0xe3,0x7c,0x79,0x71,
0x09,0xcd,0x87,0xe1,0x14,0x4c,0xb3,0xfb,0xf5,0x35,0xaf,0xa2,0xd2,0x6e,0xe0,0xcc,
0x5f,0xf2,0x55,0xe2,0xa4,0x6a,0x30,0xa7,0xda,0x16,0x24,0x86,0x39,0x07,0x0d,0x1d,
0xec,0x64,0xf0,0x3d,0xd7,0x66,0x98,0x08,0x15,0x94,0xa0,0xba,0x5b,0x22,0x3e,0x67,
0x40,0x1b,0x54,0x3a,0xb7,0x2b,0x9e,0xb0,0x4b,0xd3,0xb6,0xf3,0x8d,0xf1,0xe5,0xc4,
0x27,0x36,0x1f,0x84,0x51,0x32,0xcf,0xef,0xd4,0xd6,0xbe,0x8b,0x49,0xbb,0x83,0x31,
0x7f,0xc9,0x57,0x8a,0x91,0xa8,0xc2,0x9f,0x68,0x58,0x92,0x18,0xe4,0x1c,0x34,0x77,
0xb1,0x93,0xc0,0xf7,0x5d,0x9a,0x60,0x20,0x56,0x52,0x82,0xe9,0x6c,0x88,0xf9,0x9d,
0x00,0x6d,0x50,0xea,0xdc,0xae,0x7a,0xc1,0x2f,0x4e,0xdb,0xce,0x37,0xc7,0x97,0x10,
0x9c,0xd8,0x7e,0x11,0x44,0xcb,0x3f,0xbf,0x53,0x5a,0xfa,0x2d,0x26,0xee,0x0c,0xc5,
0xff,0x25,0x5e,0x2a,0x46,0xa3,0x0a,0x7d,0xa1,0x62,0x48,0x63,0x90,0x70,0xd1,0xde,
0xc6,0x4f,0x03,0xdd,0x76,0x69,0x80,0x81,0x59,0x4a,0x0b,0xa5,0xb2,0x23,0xe6,0x74,
0x01,0xb5,0x43,0xab,0x72,0xb9,0xeb,0x04,0xbd,0x3b,0x6f,0x38,0xdf,0x1e,0x5c,0x42,
0x73,0x61,0xf8,0x45,0x13,0x2c,0xfe,0xfd,0x4d,0x6b,0xe8,0xb4,0x9b,0xb8,0x33,0x17,
0xfc,0x95,0x78,0xa9,0x1a,0x8c,0x29,0xf6,0x85,0x89,0x21,0x8e,0x41,0xc3,0x47,0x7b,
0x19,0x3c,0x0f,0x75,0xd9,0xa6,0x02,0x05,0x65,0x28,0x2e,0x96,0xc8,0x8f,0x99,0xd0,
0x06,0xd5,0x0e,0xad,0xca,0xe7,0xac,0x12,0xf4,0xed,0xbc,0xe3,0x7c,0x79,0x71,0x09,
0xcd,0x87,0xe1,0x14,0x4c,0xb3,0xfb,0xf5,0x35,0xaf,0xa2,0xd2,0x6e,0xe0,0x59,0x34,
0xB6,0x69,0xFD,0x2E};
unsigned char head[]={0x49,0x96,0x02,0xD2,0x00,0x00,0x04,0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00};
unsigned char tail[]={0x00,0xB6,0x69,0xFD,0x2E};
unsigned char bufferSend[MAXLINE]={0};
unsigned char bufferSend2[MAXLINE]={0};
unsigned char buffer[MAXLINE];
unsigned char bufferSend3[MAXLINE]={0};

ssize_t writen(int fd,const unsigned char *ptr,int n) {
	size_t nleft;
	ssize_t nwritten;
	nleft=n;
	while(nleft>0) {
		if((nwritten=write(fd,ptr,nleft))<=0) {
			if(nwritten<0 && errno==EINTR) nwritten=0;
			else return -1;
		}
		nleft-=nwritten;
		ptr+=nwritten;
	}
	return n;
}

int addHead(unsigned char* buf,int len) {
	using namespace std;
	bzero(bufferSend3,sizeof(bufferSend3));
	int cur=0;
	copy(head,head+sizeof(head),bufferSend3+cur);
	cur=sizeof(head);
	copy(buf,buf+len,bufferSend3+cur);
	cur+=len;
	copy(tail,tail+sizeof(tail),bufferSend3+cur);
	cur+=sizeof(tail);	
	return cur;
}


class SockFD {
public:
	SockFD(int port,const char *argv) {
		sockfd=socket(AF_INET,SOCK_STREAM,0);
		bzero(&servaddr,sizeof(servaddr));
		servaddr.sin_family=AF_INET;
		servaddr.sin_port=htons(port);
		inet_pton(AF_INET,argv,&servaddr.sin_addr);
		connect(sockfd,(struct sockaddr *)&servaddr,sizeof(servaddr));
		std::cout<<"connect sucess,port:"<<port<<std::endl;
	}
	~SockFD() {
		close(sockfd);
		std::cout<<"close"<<std::endl;
	}
	int sockfd=0;
	struct sockaddr_in servaddr;
	
};

int main(int argc, char const *argv[])
{
	//建立到crt的tcp连接 端口号为port1
	SockFD sockf(port1,argv[1]);
	//建立本地的tcp 9090服务器端
	int sockfd2=0;
	int fd2 = 0;
	struct sockaddr_in servaddr2,clieaddr2;
	fd2=socket(AF_INET,SOCK_STREAM,0);
    socklen_t addrlen = sizeof(clieaddr2);
	bzero(&servaddr2,sizeof(servaddr2));
	servaddr2.sin_family=AF_INET;
	servaddr2.sin_port=htons(9090);
	servaddr2.sin_addr.s_addr=htonl(INADDR_ANY) ;
	if (bind(fd2, (const struct sockaddr *)&servaddr2, sizeof(servaddr2))<0){
		perror("connect");
		exit(1);
	}
	listen(fd2,5);
	sockfd2 = accept(fd2,(struct sockaddr*)&clieaddr2,&addrlen);
	printf("accpet ip:%s \n", inet_ntoa(clieaddr2.sin_addr)); 
	
	int totalcount=0;

	/*也可以建立本地的5002端口udp接收端
	int sockfd4=0;
	struct sockaddr_in servaddr4;
	sockfd4=socket(AF_INET,SOCK_DGRAM,0);
	bzero(&servaddr4,sizeof(servaddr4));
	servaddr4.sin_family=AF_INET;
	servaddr4.sin_port=htons(5002);
	inet_pton(AF_INET,"127.0.0.1",&servaddr4.sin_addr);*/

	int len=0;
	int count = 0;
	fd_set rset,allset;
	FD_ZERO(&allset);
	int maxfdp1;
	maxfdp1=std::max(sockfd2,0)+1;
	//可打印到文件进行分析
	//ofstream ofile;
	//ofile.open("1024send.txt");
	FD_SET(sockfd2,&allset);
	struct timeval timeout;
	timeout.tv_sec = 0;
	timeout.tv_usec = 0;
	int left = 0;
	int start = 0;
	int l =0;
	while(1) 
	{
		rset=allset;
		//通过select监听 
		int result = select(maxfdp1,&rset,nullptr,nullptr,&timeout);
		switch(result) 
		{
			//如果没收到数据 发idle包保持链路同步
			case 0:{
				std::cout<<"receive no data"<<std::endl;
				writen(sockf.sockfd,idle,sizeof(idle));
				std::cout<<"send idle"<<std::endl;
				l=read(sockf.sockfd,buffer,MAXLINE);
				std::cout<<"receive2-idle ack:"<<l<<std::endl;
				//间隙可调
				usleep(10000);
				break;
			}
			//收到数据
			default:
				if(FD_ISSET(sockfd2,&rset)) {
					if((len=read(sockfd2,buffer,MAXLINE))==0) {
						//std::cout<<"receive2 none"<<std::endl;
					} else if (len > 500){
						std::cout<<"receive2 len:"<<len<<endl;
						//考虑到高速率传输情况下的TCP粘包现象 做处理
						if(left != 0) {
							std::cout<<"left before= "<<left<<std::endl;
							std::copy(buffer,buffer+1023-left,bufferSend+left);
							for(int j=0;j<1023;++j) {
								if(j%16==0) {
									std::cout<<std::endl;
									//ofile<<std::endl;
								}
								std::cout<<std::hex<<std::setw(2)<<std::setfill('0')<<(int)bufferSend[j]<<" ";
								//ofile<<std::hex<<std::setw(2)<<std::setfill('0')<<(int)bufferSend[j]<<" ";
							}
							std::cout<<std::dec<<std::endl;
							auto toSendSize=addHead(bufferSend,1023);
							writen(sockf.sockfd,bufferSend3,toSendSize);
							printf("totalcount=%d\n",totalcount++);
							std::cout<<"left before= "<<left<<std::endl;
							start= 1023 - left;
							std::cout<<"start= "<<start<<std::endl;
						}
						else
							start=0;

						int count=(len-start) / 1023;
						left = (len-start) % 1023;
						std::cout<<"count= "<<count<<std::endl;
						std::cout<<"left now= "<<left<<std::endl;
						for(int k=0;k<count;k++){
							std::cout<<"k= "<<k<<std::endl;
							std::copy(buffer+1023*k+start,buffer+1023+1023*k+start,bufferSend2);
							std::cout<<"remove"<<std::endl;										
							for(int j=0;j<1023;++j) {
								if(j%16==0) {
									std::cout<<std::endl;
									//ofile<<std::endl;
								}
								std::cout<<std::hex<<std::setw(2)<<std::setfill('0')<<(int)bufferSend2[j]<<" ";
								//ofile<<std::hex<<std::setw(2)<<std::setfill('0')<<(int)bufferSend2[j]<<" ";
							}
							std::cout<<std::dec<<std::endl;
							auto toSendSize2=addHead(bufferSend2,1023);
							writen(sockf.sockfd,bufferSend3,toSendSize2);
							printf("totalcount=%d\n",totalcount++);
							l=read(sockf.sockfd,buffer,MAXLINE);
							std::cout<<"receive2 ack:"<<l<<std::endl;
							std::cout<<std::endl;
						}
						std::copy(buffer+1023*count+start,buffer+left+1023*count+start,bufferSend);	
					}
					else {
						//一般会大于500的
						std::cout<<"receive2 len:"<<len<<endl;
					}
				}
		}			
	}
	std::cout<<"receive done"<<std::endl;
	return 0;
}
